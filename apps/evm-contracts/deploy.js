const { execSync } = require("child_process");
const fs = require("fs");
const readline = require("readline");

const chains = require("viem/chains");

const findByChainId = (chainId) => {
  return Object.entries(chains).find(([, chain]) => chain.id === chainId);
};

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const network = process.argv[2];

if (!network) {
  console.error("Network name is required. Usage: pnpm run deploy <network>");
  process.exit(1);
}

const sepoliaParametersPath = `./ignition/parameters/sepolia.json`;
const parametersPath = `./ignition/parameters/${network}.json`;

if (!fs.existsSync(parametersPath)) {
  console.warn(`Parameters file for network ${network} does not exist.`);

  console.log(`Taking Sepolia parameters from ${sepoliaParametersPath} as defaults.`);
  const sepoliaParameters = JSON.parse(fs.readFileSync(sepoliaParametersPath, "utf-8"));

  const askUserForParameters = () => {
    return new Promise((resolve) => {
      const newParameters = { ...sepoliaParameters };
      const keys = Object.keys(sepoliaParameters);
      let index = 0;

      const askNext = () => {
        if (index < keys.length) {
          const key = keys[index];
          if (typeof newParameters[key] === "object" && newParameters[key] !== null) {
            askNestedParameters(key, newParameters[key]).then(() => {
              index++;
              askNext();
            });
          } else {
            rl.question(`Enter value for ${key} (default: ${JSON.stringify(newParameters[key])}): `, (answer) => {
              newParameters[key] = answer || sepoliaParameters[key];
              index++;
              askNext();
            });
          }
        } else {
          resolve(newParameters);
        }
      };

      const askNestedParameters = (parentKey, parentObject) => {
        return new Promise((resolve) => {
          const nestedKeys = Object.keys(parentObject);
          let nestedIndex = 0;

          const askNestedNext = () => {
            if (nestedIndex < nestedKeys.length) {
              const nestedKey = nestedKeys[nestedIndex];
              rl.question(
                `Enter value for ${parentKey}.${nestedKey} (default: ${JSON.stringify(parentObject[nestedKey])}): `,
                (answer) => {
                  parentObject[nestedKey] = answer || sepoliaParameters[parentKey][nestedKey];
                  nestedIndex++;
                  askNestedNext();
                },
              );
            } else {
              resolve();
            }
          };

          askNestedNext();
        });
      };

      askNext();
    });
  };

  askUserForParameters().then((newParameters) => {
    fs.writeFileSync(parametersPath, JSON.stringify(newParameters, null, 2));
    console.log(`Parameters file for network ${network} has been created.`);

    rl.close();
    executeDeployment();
  });
} else {
  executeDeployment();
}

function executeDeployment() {
  let command = `hardhat ignition deploy ignition/modules/CashierDeposit.ts --network ${network} --parameters ${parametersPath}`;

  try {
    execSync(command, { stdio: "inherit" });
    generateExports();
    process.exit(0);
  } catch (error) {
    console.error(`Failed to deploy to network ${network}: ${error.message}`);
    process.exit(1);
  }
}

function generateExports() {
  try {
    const deploymentFiles = fs.readdirSync("./ignition/deployments");
    let fileContents = `// This file is autogenerated by deploy.js. Do not edit manually.\n`;
    const deployedChains = [];
    deploymentFiles.forEach((folder) => {
      const chainId = parseInt(folder.split("-")[1]);
      const [key, chain] = findByChainId(chainId);
      deployedChains.push({ ...chain, key });

      fileContents += `import { abi as ${key}CashierDepositAbi } from "./ignition/deployments/${folder}/artifacts/CashierDeposit#CashierDeposit.json";\n`;
      fileContents += `import ${key}Deployments from "./ignition/deployments/${folder}/deployed_addresses.json";\n`;
      fileContents += `import ${key}Parameters from "./ignition/parameters/${key}.json";\n`;
    });

    fileContents += `\nexport default {\n  CashierDeposit: {\n`;

    // HARDCODED MAINNET DEPLOYMENT, IF REDEPLOYED REMOVE THIS
    fileContents += `    1: {\n`;
    fileContents += `      abi: sepoliaCashierDepositAbi,\n`;
    fileContents += `      address: "0x52FbEd51F99549F3C55CD2611C30A7Df29d259cd" as \`0x\${string}\`,\n`;
    fileContents += `      parameters: { allowedTokenAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" },\n`;
    fileContents += `    },\n`;

    deployedChains.forEach((chain) => {
      fileContents += `    ${chain.id}: {\n`;
      fileContents += `      abi: ${chain.key}CashierDepositAbi,\n`;
      fileContents += `      address: ${chain.key}Deployments["CashierDeposit#CashierDeposit"] as \`0x\${string}\`,\n`;
      fileContents += `      parameters: ${chain.key}Parameters["CashierDeposit"],\n`;
      fileContents += `    },\n`;
    });

    fileContents += `  },\n} as const;\n`;
    fs.writeFileSync("./exports.ts", fileContents);
    execSync("prettier --write ./exports.ts");
    console.log("exports.ts file has been generated successfully.");
  } catch (error) {
    console.error(`Failed to generate exports.ts: ${error.message}`);
    process.exit(1);
  }
}
