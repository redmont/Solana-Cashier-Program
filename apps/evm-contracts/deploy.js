const { execSync } = require("child_process");
const fs = require("fs");
const readline = require("readline");

const chains = require("viem/chains");

const findByChainId = (chainId) => {
  return Object.entries(chains).find(([, chain]) => chain.id === chainId);
};

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const usage = `Usage: pnpm run deploy <network> <contract>`;

const network = process.argv[2];

if (!network) {
  console.error(`Network name is required. ${usage}`);
  process.exit(1);
}

const contractName = process.argv[3];

if (!contractName) {
  console.error(`Contract name is required. ${usage}`);
  process.exit(1);
}

const sepoliaParametersPath = `./ignition/parameters/sepolia.json`;
const parametersPath = `./ignition/parameters/${network}.json`;

if (!fs.existsSync(parametersPath)) {
  console.warn(`Parameters file for network ${network} does not exist.`);

  console.log(`Taking Sepolia parameters from ${sepoliaParametersPath} as defaults.`);
  const sepoliaParameters = JSON.parse(fs.readFileSync(sepoliaParametersPath, "utf-8"));

  const askUserForParameters = () => {
    return new Promise((resolve) => {
      const newParameters = { ...sepoliaParameters };
      const keys = Object.keys(sepoliaParameters);
      let index = 0;

      const askNext = () => {
        if (index < keys.length) {
          const key = keys[index];
          if (typeof newParameters[key] === "object" && newParameters[key] !== null) {
            askNestedParameters(key, newParameters[key]).then(() => {
              index++;
              askNext();
            });
          } else {
            rl.question(`Enter value for ${key} (default: ${JSON.stringify(newParameters[key])}): `, (answer) => {
              newParameters[key] = answer || sepoliaParameters[key];
              index++;
              askNext();
            });
          }
        } else {
          resolve(newParameters);
        }
      };

      const askNestedParameters = (parentKey, parentObject) => {
        return new Promise((resolve) => {
          const nestedKeys = Object.keys(parentObject);
          let nestedIndex = 0;

          const askNestedNext = () => {
            if (nestedIndex < nestedKeys.length) {
              const nestedKey = nestedKeys[nestedIndex];
              rl.question(
                `Enter value for ${parentKey}.${nestedKey} (default: ${JSON.stringify(parentObject[nestedKey])}): `,
                (answer) => {
                  parentObject[nestedKey] = answer || sepoliaParameters[parentKey][nestedKey];
                  nestedIndex++;
                  askNestedNext();
                },
              );
            } else {
              resolve();
            }
          };

          askNestedNext();
        });
      };

      askNext();
    });
  };

  askUserForParameters().then((newParameters) => {
    fs.writeFileSync(parametersPath, JSON.stringify(newParameters, null, 2));
    console.log(`Parameters file for network ${network} has been created.`);

    rl.close();
    executeDeployment();
  });
} else {
  executeDeployment();
}

function executeDeployment() {
  let command = `hardhat ignition deploy ignition/modules/${contractName}.ts --network ${network} --parameters ${parametersPath}`;

  try {
    execSync(command, { stdio: "inherit" });
    generateExports();
    process.exit(0);
  } catch (error) {
    console.error(`Failed to deploy to network ${network}: ${error.message}`);
    process.exit(1);
  }
}

function generateExports() {
  try {
    const deploymentFolders = fs.readdirSync("./ignition/deployments");
    let fileContents = `// This file is autogenerated by deploy.js. Do not edit manually.\n`;
    const deployedChains = [];
    const contractNames = [];
    deploymentFolders.forEach((folder) => {
      const chainId = parseInt(folder.split("-")[1]);
      const [key, chain] = findByChainId(chainId);

      // Get .json files from the artifacts folder (excluding .dbg.json)
      const artifacts = fs
        .readdirSync(`./ignition/deployments/${folder}/artifacts`)
        .filter((file) => file.endsWith(".json") && !file.endsWith(".dbg.json"));
      const artifactFiles = artifacts.map((file) => file.replace(".json", ""));
      const contracts = artifactFiles.map((artifactFile) => ({
        name: artifactFile.split("#")[1],
        artifactFileName: artifactFile,
      }));

      deployedChains.push({ ...chain, key, contracts });

      for (const contract of contracts) {
        fileContents += `import { abi as ${key}${contract.name}Abi } from "./ignition/deployments/${folder}/artifacts/${contract.artifactFileName}.json";\n`;

        if (contractNames.indexOf(contract.name) === -1) {
          contractNames.push(contract.name);
        }
      }
      fileContents += `import ${key}Deployments from "./ignition/deployments/${folder}/deployed_addresses.json";\n`;
      fileContents += `import ${key}Parameters from "./ignition/parameters/${key}.json";\n`;
    });

    fileContents += `\nexport default {`;

    for (const contractName of contractNames) {
      fileContents += `\n  ${contractName}: {\n`;

      if (contractName === "CashierDeposit") {
        // HARDCODED MAINNET DEPLOYMENT, IF REDEPLOYED REMOVE THIS
        fileContents += `    1: {\n`;
        fileContents += `      abi: sepoliaCashierDepositAbi,\n`;
        fileContents += `      address: "0x52FbEd51F99549F3C55CD2611C30A7Df29d259cd" as \`0x\${string}\`,\n`;
        fileContents += `      parameters: { allowedTokenAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" },\n`;
        fileContents += `    },\n`;
      }

      for (const chain of deployedChains) {
        // Skip chain ID 1 for CasiherDeposit
        if (chain.id === 1 && contractName === "CashierDeposit") {
          continue;
        }

        const contract = chain.contracts.find((c) => c.name === contractName);
        if (contract) {
          fileContents += `    ${chain.id}: {\n`;
          fileContents += `      abi: ${chain.key}${contract.name}Abi,\n`;
          fileContents += `      address: ${chain.key}Deployments["${contract.artifactFileName}"] as \`0x\${string}\`,\n`;
          fileContents += `      parameters: ${chain.key}Parameters["${contract.name}"],\n`;
          fileContents += `    },\n`;
        } else {
          fileContents += `    ${chain.id}: undefined,\n`;
        }
      }

      fileContents += `  },\n`;
    }

    fileContents += `\n} as const;\n`;
    fs.writeFileSync("./exports.ts", fileContents);
    execSync("prettier --write ./exports.ts");
    console.log("exports.ts file has been generated successfully.");
  } catch (error) {
    console.error(`Failed to generate exports.ts: ${error.message}`);
    process.exit(1);
  }
}
